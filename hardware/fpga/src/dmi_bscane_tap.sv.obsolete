// Copyright 2020 ETH Zurich and University of Bologna.
// Solderpad Hardware License, Version 0.51, see LICENSE for details.
// SPDX-License-Identifier: SHL-0.51
//
// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>, adapted for Ara FPGA wrapper
//
// BSCANE2-based implementation of the riscv-dbg dmi_jtag_tap interface.
//
// This module is a drop-in replacement for
// `riscv-dbg/src/dmi_jtag_tap.sv` as used by `dmi_jtag.sv`, but instead of
// implementing a full JTAG TAP FSM itself, it hooks into Xilinx's internal
// JTAG TAP using two BSCANE2 instances:
//
//   - JTAG_CHAIN = 3 : DTMCS (Debug Transport Module Control and Status)
//   - JTAG_CHAIN = 4 : DMI (Debug Module Interface)
//
// The pad-level JTAG ports (tck_i, tms_i, trst_ni, td_i, td_o, tdo_oe_o,
// testmode_i) are unused and only present to keep the port list identical to
// the riscv-dbg dmi_jtag_tap. All meaningful JTAG information is obtained
// through BSCANE2.
//
// Limitations / differences vs the generic TAP:
// - IDCODE/BYPASS data registers are not implemented here; device IDCODE/
//   BYPASS are handled by the Xilinx configuration TAP.
// - DTMCS contents follow the 0.13 spec (abits, version, dmistat). dmi_reset_o
//   is asserted when the host writes DTMCS.dmireset = 1 via chain 3.

module dmi_jtag_tap #(
  parameter int unsigned IrLength    = 5,
  // JTAG IDCODE Value (unused here, IDCODE handled by Xilinx TAP)
  parameter logic [31:0] IdcodeValue = 32'h0000_0001
  // xxxx             version
  // xxxxxxxxxxxxxxxx part number
  // xxxxxxxxxxx      manufacturer id
  // 1                required by standard
) (
  // Pad-side JTAG pins (unused in BSCANE2-based implementation)
  input  logic        tck_i,    // JTAG test clock pad
  input  logic        tms_i,    // JTAG test mode select pad
  input  logic        trst_ni,  // JTAG test reset pad
  input  logic        td_i,     // JTAG test data input pad
  output logic        td_o,     // JTAG test data output pad
  output logic        tdo_oe_o, // Data out output enable
  input  logic        testmode_i,

  // TAP state outputs (as expected by dmi_jtag.sv)
  output logic        test_logic_reset_o,
  output logic        shift_dr_o,
  output logic        update_dr_o,
  output logic        capture_dr_o,

  // DMI / DTMCS selection and reset
  output logic        dmi_access_o,
  output logic        dtmcs_select_o,
  output logic        dmi_reset_o,
  input  logic [1:0]  dmi_error_i,

  // DMI data path
  output logic        dmi_tdi_o,
  input  logic        dmi_tdo_i
);

  // ---------------------------------------------------------------------------
  // Pad-side outputs are unused in this FPGA-specific implementation
  // ---------------------------------------------------------------------------
  assign td_o     = 1'b0;
  assign tdo_oe_o = 1'b0;

  // ---------------------------------------------------------------------------
  // BSCANE2 instances
  //
  // Chain 3: DTMCS (DTM Control/Status)
  // Chain 4: DMI (Debug Module Interface)
  // ---------------------------------------------------------------------------

  // Chain 3 (DTMCS)
  logic bscan3_capture;
  logic bscan3_shift;
  logic bscan3_update;
  logic bscan3_reset;
  logic bscan3_sel;
  logic bscan3_tck;
  logic bscan3_tdi;
  logic bscan3_tdo;

  // Chain 4 (DMI)
  logic bscan4_capture;
  logic bscan4_shift;
  logic bscan4_update;
  logic bscan4_reset;
  logic bscan4_sel;
  logic bscan4_tck;
  logic bscan4_tdi;
  // TDO driven by dmi_tdo_i

  // DTMCS via chain 3
  BSCANE2 #(
    .JTAG_CHAIN (3)
  ) i_bscan_dtmcs (
    .CAPTURE (bscan3_capture),
    .DRCK    (/* unused */),
    .RESET   (bscan3_reset),
    .RUNTEST (/* unused */),
    .SEL     (bscan3_sel),
    .SHIFT   (bscan3_shift),
    .TCK     (bscan3_tck),
    .TDI     (bscan3_tdi),
    .TMS     (/* unused */),
    .TDO     (bscan3_tdo),
    .UPDATE  (bscan3_update)
  );

  // DMI via chain 4
  BSCANE2 #(
    .JTAG_CHAIN (4)
  ) i_bscan_dmi (
    .CAPTURE (bscan4_capture),
    .DRCK    (/* unused */),
    .RESET   (bscan4_reset),
    .RUNTEST (/* unused */),
    .SEL     (bscan4_sel),
    .SHIFT   (bscan4_shift),
    .TCK     (bscan4_tck),
    .TDI     (bscan4_tdi),
    .TMS     (/* unused */),
    .TDO     (dmi_tdo_i),       // drive DMI TDO back to JTAG chain
    .UPDATE  (bscan4_update)
  );

  // ---------------------------------------------------------------------------
  // Global TAP control signals
  // ---------------------------------------------------------------------------

  // In the Xilinx JTAG architecture, RESET is asserted when the TAP is in
  // Test-Logic-Reset. Both chains see the same RESET, so OR'ing is safe.
  assign test_logic_reset_o = bscan3_reset | bscan4_reset;

  // DR phase indicators (OR of both chains)
  assign capture_dr_o = bscan3_capture | bscan4_capture;
  assign shift_dr_o   = bscan3_shift   | bscan4_shift;
  assign update_dr_o  = bscan3_update  | bscan4_update;

  // Select lines map directly to DTMCS / DMI "register" selects
  assign dtmcs_select_o = bscan3_sel;
  assign dmi_access_o   = bscan4_sel;

  // DMI TDI is simply the TDI on chain 4
  assign dmi_tdi_o = bscan4_tdi;

  // ---------------------------------------------------------------------------
  // DTMCS (Debug Transport Module Control and Status)
  //
  // Implement a minimal DTMCS register identical to the riscv-dbg TAP:
  //
  //   [31:18] zero1
  //   [   17] dmihardreset
  //   [   16] dmireset
  //   [   15] zero0
  //   [14:12] idle
  //   [11:10] dmistat
  //   [ 9: 4] abits
  //   [ 3: 0] version
  //
  // dmi_reset_o is asserted when dmireset==1 after an update.
  // ---------------------------------------------------------------------------

  typedef struct packed {
    logic [31:18] zero1;
    logic         dmihardreset;
    logic         dmireset;
    logic         zero0;
    logic [14:12] idle;
    logic [11:10] dmistat;
    logic [9:4]   abits;
    logic [3:0]   version;
  } dtmcs_t;

  dtmcs_t dtmcs_q, dtmcs_d;

  // Export the dmireset bit to the rest of the debug infrastructure
  assign dmi_reset_o = dtmcs_q.dmireset;

  // Capture / shift / update of DTMCS on chain 3
  always_comb begin
    dtmcs_d = dtmcs_q;

    // Capture current status into DTMCS when the DTMCS chain is selected
    if (bscan3_sel && bscan3_capture) begin
      dtmcs_d.zero1        = '0;
      dtmcs_d.dmihardreset = 1'b0;
      dtmcs_d.dmireset     = 1'b0;
      dtmcs_d.zero0        = '0;
      dtmcs_d.idle         = 3'd1;        // 1: Enter Run-Test/Idle and leave it immediately
      dtmcs_d.dmistat      = dmi_error_i; // 0: OK, 2: Op failed, 3: too fast
      dtmcs_d.abits        = 6'd7;        // Size of DMI address (matches riscv-dbg)
      dtmcs_d.version      = 4'd1;        // Debug spec version 0.13
    end

    // Shift operation on chain 3
    if (bscan3_sel && bscan3_shift) begin
      // Shift right through the packed DTMCS register:
      // new[31] = TDI, new[30:0] = old[31:1]
      dtmcs_d = {bscan3_tdi, dtmcs_q[31:1]};
    end

    // Synchronous reset via Test-Logic-Reset clears DTMCS
    if (test_logic_reset_o) begin
      dtmcs_d = '0;
    end
  end

  // Drive the least-significant bit of DTMCS out via BSCANE2 TDO
  // so a debugger can read back DTMCS through chain 3.
  assign bscan3_tdo = dtmcs_q[0];

  // DTMCS register update on TCK of chain 3
  always_ff @(posedge bscan3_tck or negedge trst_ni) begin
    if (!trst_ni) begin
      dtmcs_q <= '0;
    end else begin
      dtmcs_q <= dtmcs_d;
    end
  end

endmodule : dmi_jtag_tap